-- Users table for multi-tenancy
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Campaigns table to group related tasks
CREATE TABLE IF NOT EXISTS campaigns (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,                           -- Foreign key to the users table
    batch_id TEXT NOT NULL UNIQUE,                      -- A unique ID for the batch, e.g., a UUID
    user_goal_description TEXT NOT NULL,                -- The high-level goal from the user
    status TEXT DEFAULT 'pending',                      -- pending, in-progress, completed, failed
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    final_summary_report TEXT,                          -- The final report generated by the CampaignSummarizerService
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Main tasks table, now linked to campaigns
CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    campaign_id INTEGER NOT NULL,            
    user_id INTEGER NOT NULL,            -- Foreign key to campaigns table
    user_task_description TEXT NOT NULL,                -- The original campaign goal
    generated_agent_prompt TEXT NOT NULL,               -- Prompt for the Realtime Call LLM for this specific task
    business_name TEXT,
    person_name TEXT,
    phone_number TEXT NOT NULL,
    status TEXT DEFAULT 'pending',                      -- pending, in-progress, completed, failed_conclusive, on_hold, pending_analysis, pending_user_info
    overall_conclusion TEXT,                            -- Final summary for this specific task
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    next_action_time DATETIME,
    max_attempts INTEGER DEFAULT 3,
    current_attempt_count INTEGER DEFAULT 0,
    initial_schedule_time DATETIME NOT NULL,
    -- HITL (Human-in-the-Loop) support fields
    user_info_request TEXT,                             -- The question asked to the task creator
    user_info_response TEXT,                            -- The response from the task creator
    user_info_timeout INTEGER DEFAULT 10,              -- Timeout in seconds for user response
    user_info_requested_at TIMESTAMP,                   -- When the request was made
    FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE CASCADE
);

-- Individual call attempts for each task (Unchanged)
CREATE TABLE IF NOT EXISTS calls (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    attempt_number INTEGER NOT NULL,
    scheduled_time DATETIME NOT NULL,
    status TEXT DEFAULT 'pending_initiation',
    asterisk_channel TEXT,
    call_uuid TEXT UNIQUE,
    asterisk_call_uuid TEXT UNIQUE DEFAULT NULL, -- Explicitly adding for clarity, though call_uuid could be repurposed. Let's keep call_uuid as it is and add the new one for Asterisk specific UUID for now. The Wayforward planned to use call_uuid for the Asterisk UUID. I will stick to the plan and use call_uuid for the Asterisk specific UUID for now, and rename it if we find it confusing later. Let's assume 'call_uuid' in the schema IS the asterisk_call_uuid for now, as per the Wayforward's note "call_uuid is the parameter name in _update_call_status_db that will map to asterisk_call_uuid in the database."
    prompt_used TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    call_conclusion TEXT,
    hangup_cause TEXT,
    duration_seconds INTEGER,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

-- Transcripts for each call attempt (Unchanged)
CREATE TABLE IF NOT EXISTS call_transcripts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    call_id INTEGER NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    speaker TEXT NOT NULL CHECK(speaker IN ('user', 'agent', 'system')),
    message TEXT NOT NULL,
    FOREIGN KEY (call_id) REFERENCES calls(id) ON DELETE CASCADE
);

-- Events happening during a call attempt (Unchanged)
CREATE TABLE IF NOT EXISTS call_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    call_id INTEGER NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    event_type TEXT NOT NULL,
    details TEXT,
    FOREIGN KEY (call_id) REFERENCES calls(id) ON DELETE CASCADE
);

-- Task events table for tracking task lifecycle changes
CREATE TABLE IF NOT EXISTS task_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    event_type TEXT NOT NULL,                           -- e.g., 'status_changed', 'retry_scheduled', 'user_info_requested'
    event_details TEXT,                                 -- JSON string with event-specific data
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by TEXT DEFAULT 'system',                   -- 'system', 'user', or service name
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS dnd_list (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL, -- <<< ADD THIS LINE
    phone_number TEXT NOT NULL, -- Keep this, but a user might DND a number another user wants to call
    reason TEXT,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    task_id INTEGER, -- This can be kept to know which task triggered the DND initially
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE, -- <<< ADD THIS FK
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL,
    UNIQUE(user_id, phone_number) -- <<< ADD UNIQUE constraint for user_id + phone_number
);

-- Triggers for updated_at (Unchanged)
CREATE TRIGGER IF NOT EXISTS tasks_updated_at_trigger
AFTER UPDATE ON tasks
FOR EACH ROW
BEGIN
    UPDATE tasks SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;

CREATE TRIGGER IF NOT EXISTS calls_updated_at_trigger
AFTER UPDATE ON calls
FOR EACH ROW
BEGIN
    UPDATE calls SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;

-- Indexes for performance (Updated)
CREATE INDEX IF NOT EXISTS idx_users_username ON users (username);
CREATE INDEX IF NOT EXISTS idx_campaigns_user_id ON campaigns (user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_campaign_id ON tasks (campaign_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status_next_action_time ON tasks (status, next_action_time);
CREATE INDEX IF NOT EXISTS idx_calls_task_id ON calls (task_id);
CREATE INDEX IF NOT EXISTS idx_calls_status ON calls (status);
CREATE INDEX IF NOT EXISTS idx_call_transcripts_call_id ON call_transcripts (call_id);
CREATE INDEX IF NOT EXISTS idx_call_events_call_id ON call_events (call_id);
CREATE INDEX IF NOT EXISTS idx_dnd_list_phone_number ON dnd_list (phone_number);
CREATE INDEX IF NOT EXISTS idx_tasks_pending_user_info ON tasks (status, user_info_requested_at) WHERE status = 'pending_user_info';
CREATE INDEX IF NOT EXISTS idx_tasks_user_info_timeout ON tasks (user_info_requested_at, user_info_timeout);
CREATE INDEX IF NOT EXISTS idx_task_events_task_id ON task_events (task_id);
CREATE INDEX IF NOT EXISTS idx_task_events_event_type ON task_events (event_type);
CREATE INDEX IF NOT EXISTS idx_task_events_created_at ON task_events (created_at);