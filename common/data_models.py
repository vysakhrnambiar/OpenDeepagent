import sys
from pathlib import Path
from typing import Optional, Dict, Any, List, Literal
from datetime import datetime
from pydantic import BaseModel, Field

# --- Path Hack for direct execution (if needed for testing this file) ---
# This can be removed if not needed, but is harmless.
_project_root = Path(__file__).resolve().parent.parent
if str(_project_root) not in sys.path:
    sys.path.insert(0, str(_project_root))
# --- End Path Hack ---

# --- API Request Models ---

class ChatInteractionRequest(BaseModel):
    """
    Model for a single user message sent to the chat interaction endpoint.
    """
    username: str = Field(..., description="The username of the user.")
    message: str = Field(..., description="The user's message text.")
    history: List[Dict[str, Any]] = Field(default_factory=list, description="The preceding conversation history.")


class CampaignExecutionRequest(BaseModel):
    """
    Model for the final request to execute a campaign plan.
    """
    username: str = Field(..., description="The username of the user initiating the campaign.")
    campaign_plan: Dict[str, Any] = Field(..., description="The final campaign plan JSON object generated by the UI assistant.")

# --- The rest of the file remains the same ---
class WebTaskRefinementDetails(BaseModel):
    """
    Model for sending task description and current details to the API
    for generating or refining an agent prompt.
    """
    user_task_description: str = Field(..., description="The user's description of the task for the AI agent.")
    current_collected_details: Optional[Dict[str, Any]] = Field(None, description="Details already collected from the user in previous steps, if any.")


class WebScheduleTaskRequest(BaseModel):
    """
    Model for scheduling a new task. The backend will parse details from the prompts.
    """
    user_task_description: str = Field(..., description="The original task description provided by the user.")
    generated_agent_prompt: str = Field(..., description="The finalized prompt for the AI agent.")


class ApiResponse(BaseModel):
    """
    Generic API response model.
    """
    success: bool = Field(..., description="Indicates if the operation was successful.")
    message: Optional[str] = Field(None, description="A message providing more details, especially on failure.")
    data: Optional[Dict[str, Any]] = Field(None, description="Optional data payload, e.g., created resource ID.")


class GeneratedPromptResponse(BaseModel):
    """
    Response from the agent prompt generation endpoint.
    """
    status: str = Field(..., description="Status of the prompt generation (e.g., 'needs_more_info', 'prompt_generated', 'error').")
    questions_for_user: Optional[str] = Field(None, description="Questions for the user if more information is needed.")
    agent_prompt: Optional[str] = Field(None, description="The generated agent prompt if successful.")
    message: Optional[str] = Field(None, description="Error message if the status is 'error'.")
    raw_llm_output: Optional[str] = Field(None, description="Raw output from LLM for debugging if format was unexpected.")

class TaskBasicInfo(BaseModel):
    id: int
    user_task_description: str
    phone_number: str
    status: str
    next_action_time: Optional[datetime] = None
    overall_conclusion: Optional[str] = None
    current_attempt_count: int
    max_attempts: int

class TaskListResponse(ApiResponse):
    """

    API response for listing tasks.
    'data' field will contain a list of tasks.
    Using a more specific data type here.
    """
    success: bool
    data: Optional[List[TaskBasicInfo]] = None
    total_tasks: Optional[int] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class RedisCommandBase(BaseModel):
    command_type: str

class RedisDTMFCommand(RedisCommandBase):
    command_type: Literal["send_dtmf"] = "send_dtmf"
    call_attempt_id: int
    digits: str = Field(..., description="DTMF digits to send (0-9, *, #).")

class RedisEndCallCommand(RedisCommandBase):
    command_type: Literal["end_call"] = "end_call"
    call_attempt_id: int
    reason: str = Field("AI decided to end the call.", description="Reason for ending the call.", max_length=2000)
    outcome: str = Field(..., description="Call outcome: success, failure, dnd, user_busy", pattern="^(success|failure|dnd|user_busy)$")
    final_message: Optional[str] = Field(None, description="The final message spoken by the AI, used for timing the hangup.")

class RedisRescheduleCommand(RedisCommandBase):
    command_type: Literal["reschedule_call_trigger_analysis"] = "reschedule_call_trigger_analysis"
    call_attempt_id: int
    reason: str
    time_description: str